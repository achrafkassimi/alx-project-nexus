{% extends 'base.html' %}
{% load static %}

{% block content %}
<div class="container mt-5">
  <div class="row">
    <!-- Sidebar: Users List -->
    <div class="col-md-4">
      <div class="card">
        <div class="card-header">
          <h5>ðŸ“œ Users</h5>
        </div>
        <ul class="list-group list-group-flush">
          {% for user in users %}
          <a href="{% url 'chat_with_user' user.id %}"
             class="list-group-item list-group-item-action {% if user.id == other_user.id %}active{% endif %}">
            {{ user.username }}
          </a>
        {% endfor %}
        </ul>
      </div>
    </div>

    <!-- Chat Interface -->
    <div class="col-md-8">
      <div class="card">
        <div class="card-header">
          <h4>ðŸ’¬ Chat with {{ other_user.username }}</h4>
        </div>
        <div class="card-body" id="chat-box" style="height: 300px; overflow-y: scroll;">
          <!-- Messages will appear here -->
        </div>
        <div class="card-footer">
          <form id="chat-form">
            <div class="input-group">
              <input type="text" id="chat-message-input" class="form-control" placeholder="Type your message...">
              <button class="btn btn-primary" type="submit">Send</button>
            </div>
          </form>
        </div>
      </div>
    </div>
  </div>
</div>

<script>
  const otherUserId = "{{ other_user.id }}";
  const username = "{{ request.user.username }}";
  const chatBox = document.getElementById("chat-box");
  
  // Create single WebSocket connection
  const chatSocket = new WebSocket(
    'ws://' + window.location.host + '/ws/chat/' + otherUserId + '/'
  );
  
  // Handle incoming WebSocket messages
  chatSocket.onmessage = function(e) {
    const data = JSON.parse(e.data);
    chatBox.innerHTML += `<div><strong>${data.sender}:</strong> ${data.message}</div>`;
    chatBox.scrollTop = chatBox.scrollHeight;
  };
  
  chatSocket.onopen = function(e) {
    console.log("WebSocket connection opened");
  };
  
  chatSocket.onclose = function(e) {
    console.error('Chat socket closed unexpectedly');
  };

  chatSocket.onerror = function(e) {
    console.error("WebSocket error:", e);
  };

  // Fetch existing messages from GraphQL when page loads
  function fetchMessages() {
    fetch('/graphql/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCSRFToken(),
      },
      body: JSON.stringify({
        query: `
          query {
            messages(otherUserId: ${otherUserId}) {
              id
              content
              sender {
                username
              }
              timestamp
            }
          }
        `
      }),
    })
    .then(res => res.json())
    .then(res => {
      chatBox.innerHTML = '';
      res.data.messages.forEach(msg => {
        chatBox.innerHTML += `<div><strong>${msg.sender.username}:</strong> ${msg.content}</div>`;
      });
      chatBox.scrollTop = chatBox.scrollHeight;
    })
    .catch(err => console.error('Error fetching messages:', err));
  }
  
  // Load messages on page load
  fetchMessages();
  
  // Handle form submission - send message via GraphQL then broadcast via WebSocket
  document.getElementById("chat-form").onsubmit = function(e) {
    e.preventDefault();
    const messageInput = document.getElementById("chat-message-input");
    const message = messageInput.value.trim();
    if (!message) return;
  
    // Send message via GraphQL mutation first
    fetch('/graphql/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCSRFToken(),
      },
      body: JSON.stringify({
        query: `
          mutation {
            sendMessage(receiverId: ${otherUserId}, content: "${message.replace(/"/g, '\\"')}") {
              message {
                id
                content
                sender {
                  username
                }
              }
            }
          }
        `
      }),
    })
    .then(res => res.json())
    .then(() => {
      // After successful GraphQL save, broadcast via WebSocket
      if (chatSocket.readyState === WebSocket.OPEN) {
        chatSocket.send(JSON.stringify({
          message: message,
        }));
        messageInput.value = "";
      } else {
        console.warn("WebSocket not ready");
      }
    })
    .catch(err => console.error('Error sending message:', err));
  };
  
  function getCSRFToken() {
    return document.cookie
      .split("; ")
      .find(row => row.startsWith("csrftoken="))
      .split("=")[1];
  }
</script>

{% endblock %}