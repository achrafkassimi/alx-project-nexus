{% extends 'base.html' %}
{% load static %}

{% block content %}
<div class="container mt-5">
  <div class="row">
    <!-- Sidebar: Users List -->
    <div class="col-md-4">
      <div class="card">
        <div class="card-header">
          <h5>ðŸ“œ Users</h5>
        </div>
        <ul class="list-group list-group-flush">
          {% for item in users_with_unread %}
          <a href="{% url 'chat_with_user' item.user.id %}"
             class="list-group-item list-group-item-action d-flex justify-content-between align-items-center {% if item.user.id == other_user.id %}active{% endif %}">
            
            <div class="d-flex align-items-center">
              <!-- Unread indicator dot -->
              {% if item.unread_count > 0 %}
                <span class="badge badge-danger badge-pill me-2" style="width: 8px; height: 8px; border-radius: 50%; padding: 0; margin-right: 8px;"></span>
              {% endif %}
              
              <span>{{ item.user.username }}</span>
            </div>
            
            <!-- Unread count badge -->
            {% if item.unread_count > 0 %}
              <span class="badge badge-primary badge-pill">{{ item.unread_count }}</span>
            {% endif %}
          </a>
          {% endfor %}
        </ul>
      </div>
    </div>

    <!-- Chat Interface -->
    <div class="col-md-8">
      <div class="card">
        <div class="card-header">
          <h4>ðŸ’¬ Chat with 
            {% if other_user %}
              {{ other_user.username }}
            {% else %}
              (Select a user)
            {% endif %}
          </h4>
        </div>
        <div class="card-body" id="chat-box" style="height: 400px; overflow-y: scroll; background-color: #f8f9fa; padding: 15px;">
          <!-- Messages will appear here -->
          {% if not other_user %}
            <div class="text-center text-muted mt-5">
              <i class="bi bi-chat-dots" style="font-size: 3rem; opacity: 0.3;"></i>
              <p class="mt-3">Select a user from the sidebar to start chatting</p>
            </div>
          {% endif %}
        </div>
        {% if other_user %}
        <div class="card-footer">
          <form id="chat-form">
            <div class="input-group">
              <input type="text" id="chat-message-input" class="form-control" placeholder="Type your message..." autocomplete="off">
              <button class="btn btn-primary" type="submit">
                <i class="bi bi-send"></i> Send
              </button>
            </div>
          </form>
        </div>
        {% endif %}
      </div>
    </div>
  </div>
</div>

{% if other_user %}
<script>
  const otherUserId = "{{ other_user.id }}";
  const currentUsername = "{{ request.user.username }}";
  const chatBox = document.getElementById("chat-box");
  
  // Create WebSocket connection
  const chatSocket = new WebSocket(
    'ws://' + window.location.host + '/ws/chat/' + otherUserId + '/'
  );
  
  // Handle incoming WebSocket messages
  chatSocket.onmessage = function(e) {
    console.log("Received WebSocket message:", e.data);
    const data = JSON.parse(e.data);
    
    if (data.type === 'chat_message') {
      addMessageToChat(data.message, data.sender, data.timestamp);
    } else if (data.type === 'unread_notification') {
      // Update unread indicator for the sender in sidebar
      updateUnreadIndicatorForUser(data.sender_id, data.sender_username);
    }
  };
  
  chatSocket.onopen = function(e) {
    console.log("WebSocket connection opened successfully");
  };
  
  chatSocket.onclose = function(e) {
    console.error('WebSocket connection closed:', e);
  };

  chatSocket.onerror = function(e) {
    console.error("WebSocket error:", e);
  };

  // Function to add message to chat UI
  function addMessageToChat(message, sender, timestamp) {
    const messageDiv = document.createElement('div');
    messageDiv.className = 'mb-3';
    
    const isCurrentUser = sender === currentUsername;
    
    messageDiv.innerHTML = `
      <div class="d-flex ${isCurrentUser ? 'justify-content-end' : 'justify-content-start'}">
        <div class="p-3 rounded ${isCurrentUser ? 'bg-primary text-white' : 'bg-white border'}" 
             style="max-width: 70%; word-wrap: break-word;">
          <div class="font-weight-bold mb-1">${isCurrentUser ? 'You' : sender}</div>
          <div>${message}</div>
          <small class="d-block mt-1 ${isCurrentUser ? 'text-light' : 'text-muted'}" style="font-size: 0.75rem;">
            ${formatTimestamp(timestamp)}
          </small>
        </div>
      </div>
    `;
    
    chatBox.appendChild(messageDiv);
    chatBox.scrollTop = chatBox.scrollHeight;
  }

  // Function to format timestamp
  function formatTimestamp(timestamp) {
    if (!timestamp) return 'now';
    const date = new Date(timestamp);
    return date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
  }

  // Function to update unread indicator for specific user
  function updateUnreadIndicatorForUser(senderId, senderUsername) {
    // Only update if we're not currently chatting with this user
    if (senderId != otherUserId) {
      // Find the user in sidebar and add/update unread indicator
      const userLinks = document.querySelectorAll('.list-group-item-action');
      userLinks.forEach(link => {
        const username = link.querySelector('span:last-child').textContent.trim();
        if (username === senderUsername) {
          // Add red dot if not exists
          if (!link.querySelector('.badge-danger')) {
            const dot = document.createElement('span');
            dot.className = 'badge badge-danger badge-pill me-2 unread-indicator';
            dot.style.cssText = 'width: 8px; height: 8px; border-radius: 50%; padding: 0; margin-right: 8px;';
            link.querySelector('div').insertBefore(dot, link.querySelector('span'));
          }
          
          // Update or add count badge
          let countBadge = link.querySelector('.badge-primary');
          if (countBadge) {
            const currentCount = parseInt(countBadge.textContent) || 0;
            countBadge.textContent = currentCount + 1;
          } else {
            countBadge = document.createElement('span');
            countBadge.className = 'badge badge-primary badge-pill';
            countBadge.textContent = '1';
            link.appendChild(countBadge);
          }
        }
      });
    }
  }

  // Fetch existing messages from GraphQL when page loads
  function fetchMessages() {
    fetch('/graphql/', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'X-CSRFToken': getCSRFToken(),
      },
      body: JSON.stringify({
        query: `
          query {
            messages(otherUserId: ${otherUserId}) {
              id
              content
              sender {
                username
              }
              timestamp
            }
          }
        `
      }),
    })
    .then(res => res.json())
    .then(res => {
      console.log("Fetched messages:", res.data);
      chatBox.innerHTML = '';
      
      if (res.data && res.data.messages) {
        res.data.messages.forEach(msg => {
          addMessageToChat(msg.content, msg.sender.username, msg.timestamp);
        });
      }
      
      chatBox.scrollTop = chatBox.scrollHeight;
    })
    .catch(err => {
      console.error('Error fetching messages:', err);
      chatBox.innerHTML = '<p class="text-danger text-center mt-4">Error loading messages</p>';
    });
  }
  
  // Mark messages as read when opening chat
  function markAsRead() {
    fetch(`/chat/mark-read/${otherUserId}/`, {
      method: 'POST',
      headers: {
        'X-CSRFToken': getCSRFToken(),
        'Content-Type': 'application/json',
      },
    })
    .then(response => response.json())
    .then(data => {
      console.log('Messages marked as read');
    })
    .catch(err => console.error('Error marking messages as read:', err));
  }

  // Load messages and mark as read on page load
  fetchMessages();
  markAsRead();
  
  // Handle form submission - send via WebSocket only
  document.getElementById("chat-form").onsubmit = function(e) {
    e.preventDefault();
    const messageInput = document.getElementById("chat-message-input");
    const message = messageInput.value.trim();
    if (!message) return;

    console.log("Sending message via WebSocket:", message);

    // Send directly via WebSocket
    if (chatSocket.readyState === WebSocket.OPEN) {
      chatSocket.send(JSON.stringify({
        message: message,
      }));
      messageInput.value = "";
    } else {
      console.warn("WebSocket not ready, state:", chatSocket.readyState);
      alert("Connection not ready. Please try again.");
    }
  };
  
  function getCSRFToken() {
    const cookieValue = document.cookie
      .split('; ')
      .find(row => row.startsWith('csrftoken='));
    return cookieValue ? cookieValue.split('=')[1] : null;
  }
</script>
{% endif %}

<style>
/* Custom styling for unread indicators */
.unread-indicator {
  width: 10px;
  height: 10px;
  background-color: #dc3545;
  border-radius: 50%;
  display: inline-block;
  margin-right: 8px;
  animation: pulse 2s infinite;
}

@keyframes pulse {
  0% { transform: scale(1); opacity: 1; }
  50% { transform: scale(1.1); opacity: 0.7; }
  100% { transform: scale(1); opacity: 1; }
}

.message-bubble {
  animation: slideIn 0.3s ease-out;
}

@keyframes slideIn {
  from { opacity: 0; transform: translateY(10px); }
  to { opacity: 1; transform: translateY(0); }
}

/* Hover effect for user list */
.list-group-item-action:hover {
  background-color: #e9ecef !important;
  transition: background-color 0.2s ease;
}

.list-group-item.active {
  background-color: #007bff !important;
  border-color: #007bff !important;
}
</style>

{% endblock %}